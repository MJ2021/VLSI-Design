-- simple gates with trivial architectures


library IEEE;
use IEEE.std_logic_1164.all;
entity andgate is
	port (A, B: in std_logic;
		  prod: out std_logic);
end entity andgate;
architecture trivial of andgate is
begin
	prod <= A AND B AFTER 46 ps;
end architecture trivial;


library IEEE;
use IEEE.std_logic_1164.all;
entity orgate is
	port (A, B: in std_logic;
		  addi: out std_logic);
end entity orgate;
architecture trivial of orgate is
begin
	addi <= A OR B AFTER 46 ps;
end architecture trivial;


library IEEE;
use IEEE.std_logic_1164.all;
entity xorgate is
	port (A, B: in std_logic;
		  uneq: out std_logic);
end entity xorgate;
architecture trivial of xorgate is
begin
	uneq <= A XOR B AFTER 72 ps;
end architecture trivial;


library IEEE;
use IEEE.std_logic_1164.all;
entity abcgate is
	port (A, B, C: in std_logic;
		      abc: out std_logic);
end entity abcgate;
architecture trivial of abcgate is
begin
	abc <= A OR (B AND C) AFTER 62 ps;
end architecture trivial;


-- A + C.(A+B) with a trivial architecture
library IEEE;
use IEEE.std_logic_1164.all;
entity Cin_map_G is
	port(A, B, Cin: in std_logic;
		    Bit0_G: out std_logic);
end entity Cin_map_G;
architecture trivial of Cin_map_G is
begin
	Bit0_G <= (A AND B) OR (Cin AND (A OR B)) AFTER 72 ps;
end architecture trivial;


library IEEE;
use IEEE.std_logic_1164.all;
entity HA is
	port(A, B: in std_logic;
		 Sum, Cout: out std_logic);
end entity HA;
architecture trivial of HA is

component andgate is
	port (A, B: in std_logic;
		  prod: out std_logic);
	end component andgate;
component xorgate is
	port (A, B: in std_logic;
		  uneq: out std_logic);
	end component xorgate;
begin
	HA0 : xorgate port map(A, B, Sum);
	FA1 : andgate port map(A, B, Cout);
end architecture trivial;


library IEEE;
use IEEE.std_logic_1164.all;
entity FA is
	port(A, B, Cin: in std_logic;
		    Sum, Cout: out std_logic);
end entity FA;
architecture trivial of FA is

component andgate is
	port (A, B: in std_logic;
		  prod: out std_logic);
	end component andgate;
	
component xorgate is
	port (A, B: in std_logic;
		  uneq: out std_logic);
	end component xorgate;

component orgate is
	port (A, B: in std_logic;
		  addi: out std_logic);
	end component orgate;

signal a1, a2, a3 : std_logic;
begin
	
	FA0 : xorgate port map(A, B, a1);
	FA1 : andgate port map(A, B, a2);
	FA2 : andgate port map(a1, Cin, a3);
	FA3 : orgate  port map(a2, a3, Cout);
	FA4 : xorgate port map(a1, Cin, Sum);
	
end architecture trivial;



library IEEE;
use IEEE.std_logic_1164.all;
entity Brent_Kung_Adder_16bit is
	port(A, B: in std_logic_vector(15 downto 0);
		 Cin : in std_logic;
		 Sum : out std_logic_vector(15 downto 0);
		 Cout: out std_logic);
end entity Brent_Kung_Adder_16bit;	 
architecture Brent_Kung_Adder_16bit_arch of Brent_Kung_Adder_16bit is
	signal G1, P1, C_vect: std_logic_vector(15 downto 0);
	signal G2, P2        : std_logic_vector(7 downto 0);
	signal G3, P3        : std_logic_vector(3 downto 0);
	signal G4, P4        : std_logic_vector(1 downto 0);
	signal G5, P5        : std_logic_vector(0 downto 0);
	
	component andgate is
	port (A, B: in std_logic;
		  prod: out std_logic);
	end component andgate;
	
	component xorgate is
	port (A, B: in std_logic;
		  uneq: out std_logic);
	end component xorgate;
	
	component abcgate is
	port (A, B, C: in std_logic;
		      abc: out std_logic);
    end component abcgate;
	
	component Cin_map_G is
	port(A, B, Cin: in std_logic;
		    Bit0_G: out std_logic);
	end component Cin_map_G;
	
begin
	
	C_vect(0) <= Cin;
	
	-- right edge carry calculation
	
	C_vect(1) <= G1(0);
	C_vect(2) <= G2(0);
	C_vect(4) <= G3(0);
	C_vect(8) <= G4(0);
	Cout      <= G5(0);
	
	
	-- 1st order P-G calculations
	
	G1_0: Cin_map_G port map(A(0), B(0), C_vect(0), G1(0));
	P1_0: xorgate port map(A(0), B(0), P1(0));
	
	G1_generate : for ii in 1 to 15 generate
		
		G1_insta: andgate port map(A(ii), B(ii), G1(ii));
		P1_insta: xorgate port map(A(ii), B(ii), P1(ii));
	
	end generate G1_generate;
	
	--2nd order P-G Calculations
	G2_generate : for ii in 0 to 7 generate
		
		G2_insta: abcgate port map(G1(2*ii+1), P1(2*ii+1), G1(2*ii), G2(ii));
		P2_insta: andgate port map(P1(2*ii+1), P1(2*ii), P2(ii));
	
	end generate G2_generate;

	--3rd order P-G calculations
	
	G3_generate : for ii in 0 to 3 generate
		
		G3_insta: abcgate port map(G2(2*ii+1), P2(2*ii+1), G2(2*ii), G3(ii));
		P3_insta: andgate port map(P2(2*ii+1), P2(2*ii), P3(ii));
	
	end generate G3_generate;
	
	--4th  order P-G Calculations
	
	G4_generate : for ii in 0 to 1 generate
		
		G4_insta: abcgate port map(G3(2*ii+1), P3(2*ii+1), G3(2*ii), G4(ii));
		P4_insta: andgate port map(P3(2*ii+1), P3(2*ii), P4(ii));
	
	end generate G4_generate;
	
	--5th order P-G calculations
	
	G5_generate : for ii in 0 to 0 generate
		
		G5_insta: abcgate port map(G4(2*ii+1), P4(2*ii+1), G4(2*ii), G5(ii));
		P5_insta: andgate port map(P4(2*ii+1), P4(2*ii), P5(ii));
	
	end generate G5_generate;
	
-- Carry Calculations

carry3: abcgate port map(G1(2), P1(2), C_vect(2), C_vect(3));
carry5: abcgate port map(G1(4), P1(4), C_vect(4), C_vect(5));
carry6: abcgate port map(G2(2), P2(2), C_vect(4), C_vect(6));
carry7: abcgate port map(G1(6), P1(6), C_vect(6), C_vect(7));
carry9: abcgate port map(G1(8), P1(8), C_vect(8), C_vect(9));
carry10: abcgate port map(G2(4), P2(4), C_vect(8), C_vect(10));
carry11: abcgate port map(G1(10), P1(10), C_vect(10), C_vect(11));
carry12: abcgate port map(G3(2), P3(2), C_vect(8), C_vect(12));
carry13: abcgate port map(G1(12), P1(12), C_vect(12), C_vect(13));
carry14: abcgate port map(G2(6), P2(6), C_vect(12), C_vect(14));
carry15: abcgate port map(G1(14), P1(14), C_vect(14), C_vect(15));

sum_generate : for ii in 0 to 15 generate
		
	sum_insta: xorgate port map(C_vect(ii), P1(ii), Sum(ii));
	
	
end generate sum_generate;

end architecture Brent_Kung_Adder_16bit_arch;


library IEEE;
use IEEE.std_logic_1164.all;
entity MAC_8x8_Dadda is
	port(A, B: in std_logic_vector(7 downto 0);
		 ACC : in std_logic_vector(15 downto 0);
		 Sum : out std_logic_vector(15 downto 0);
		 Cout: out std_logic);
end entity MAC_8x8_Dadda;	

architecture MAC_8x8_Dadda_arch of MAC_8x8_Dadda is

component andgate is
	port (A, B: in std_logic;
		  prod: out std_logic);
	end component andgate;

component FA is
	port (A, B, Cin: in std_logic;
		    Sum, Cout: out std_logic);
	end component FA;
	
component HA is
	port (A, B: in std_logic;
		   Sum, Cout: out std_logic);
	end component HA;

component Brent_Kung_Adder_16bit is
	port(A, B: in std_logic_vector(15 downto 0);
		 Cin : in std_logic;
		 Sum : out std_logic_vector(15 downto 0);
		 Cout: out std_logic);
	end component Brent_Kung_Adder_16bit;	

type partial_array is array(0 to 7, 7 downto 0) of std_logic ;
signal and_array : partial_array ;
signal stage_9_sum, stage_9_carry   : std_logic_vector(11 downto 0);
signal stage_6_sum, stage_6_carry   : std_logic_vector(17 downto 0);
signal stage_4_sum, stage_4_carry  : std_logic_vector(11 downto 0);
signal stage_3_sum, stage_3_carry   : std_logic_vector(13 downto 0);
signal final_sums, final_carries : std_logic_vector(15 downto 0);


begin

	AND_generate_ii : for ii in 0 to 7 generate
		AND_generate_jj : for jj in 0 to 7 generate
			
				and_insta: andgate port map(A(jj),B(ii),and_array(ii,jj));
				
		
		end generate AND_generate_jj;
	end generate AND_generate_ii;

-- Stage with Capacity = 9 bits

Nine_HA5   : HA port map(ACC(5), and_array(0,5), stage_9_sum(0), stage_9_carry(0));
Nine_FA6   : FA port map(ACC(6), and_array(0,6), and_array(1,5), stage_9_sum(1), stage_9_carry(1));
Nine_HA6   : HA port map(and_array(2,4), and_array(3,3), stage_9_sum(2), stage_9_carry(2));
Nine_FA7_0 : FA port map(ACC(7), and_array(0,7), and_array(1,6), stage_9_sum(3), stage_9_carry(3));
Nine_FA7_1 : FA port map(and_array(2,5), and_array(3,4), and_array(4,3), stage_9_sum(4), stage_9_carry(4));
Nine_HA7   : HA port map(and_array(5,2), and_array(6,1), stage_9_sum(5), stage_9_carry(5));
Nine_FA8_0 : FA port map(ACC(8), and_array(1,7), and_array(2,6), stage_9_sum(6), stage_9_carry(6));
Nine_FA8_1 : FA port map(and_array(3,5), and_array(4,4), and_array(5,3), stage_9_sum(7), stage_9_carry(7));
Nine_HA8   : HA port map(and_array(6,2), and_array(7,1), stage_9_sum(8), stage_9_carry(8));
Nine_FA9_0 : FA port map(ACC(9), and_array(2,7), and_array(3,6), stage_9_sum(9), stage_9_carry(9));
Nine_FA9_1 : FA port map(and_array(4,5), and_array(5,4), and_array(6,3), stage_9_sum(10), stage_9_carry(10));
Nine_FA10  : FA port map(ACC(10), and_array(3,7), and_array(4,6), stage_9_sum(11), stage_9_carry(11));


-- Stage with Capacity = 6 bits

Six_HA3   : HA port map(ACC(3), and_array(0,3), stage_6_sum(0), stage_6_carry(0));
Six_FA4   : FA port map(ACC(4), and_array(0,4), and_array(1,3), stage_6_sum(1), stage_6_carry(1));
Six_HA4   : HA port map(and_array(2,2), and_array(3,1), stage_6_sum(2), stage_6_carry(2));
Six_FA5_0 : FA port map(stage_9_sum(0), and_array(1,4), and_array(2,3), stage_6_sum(3), stage_6_carry(3));
Six_FA5_1 : FA port map(and_array(3,2), and_array(4,1), and_array(5,0), stage_6_sum(4), stage_6_carry(4));
Six_FA6_0 : FA port map(stage_9_sum(1), stage_9_carry(0), stage_9_sum(2), stage_6_sum(5), stage_6_carry(5));
Six_FA6_1 : FA port map(and_array(4,2), and_array(5,1), and_array(6,0), stage_6_sum(6), stage_6_carry(6));
Six_FA7_0 : FA port map(stage_9_sum(3), stage_9_carry(1), stage_9_sum(4), stage_6_sum(7), stage_6_carry(7));
Six_FA7_1 : FA port map(stage_9_carry(2), stage_9_sum(5), and_array(7,0), stage_6_sum(8), stage_6_carry(8));
Six_FA8_0 : FA port map(stage_9_sum(6), stage_9_carry(3), stage_9_sum(7), stage_6_sum(9), stage_6_carry(9));
Six_FA8_1 : FA port map(stage_9_carry(4), stage_9_sum(8), stage_9_carry(5), stage_6_sum(10), stage_6_carry(10));
Six_FA9_0 : FA port map(stage_9_sum(9), stage_9_carry(6), stage_9_sum(10), stage_6_sum(11), stage_6_carry(11));
Six_FA9_1 : FA port map(stage_9_carry(7), and_array(7,2), stage_9_carry(8), stage_6_sum(12), stage_6_carry(12));
Six_FA10_0: FA port map(stage_9_sum(11), stage_9_carry(9), and_array(5,5), stage_6_sum(13), stage_6_carry(13));
Six_FA10_1: FA port map(stage_9_carry(10), and_array(6,4), and_array(7,3), stage_6_sum(14), stage_6_carry(14));
Six_FA11_0: FA port map(ACC(11), stage_9_carry(11), and_array(4,7), stage_6_sum(15), stage_6_carry(15));
Six_FA11_1: FA port map(and_array(5,6), and_array(6,5), and_array(7,4), stage_6_sum(16), stage_6_carry(16));
Six_FA12  : FA port map(ACC(12), and_array(5,7), and_array(6,6), stage_6_sum(17), stage_6_carry(17));


-- Stage with Capacity = 4 bits

Four_HA2  : HA port map(ACC(2), and_array(0,2), stage_4_sum(0), stage_4_carry(0));
Four_FA3  : FA port map(stage_6_sum(0), and_array(1,2), and_array(2,1), stage_4_sum(1), stage_4_carry(1));
Four_FA4  : FA port map(stage_6_sum(1), stage_6_carry(0), stage_6_sum(2), stage_4_sum(2), stage_4_carry(2));
Four_FA5  : FA port map(stage_6_sum(3), stage_6_carry(1), stage_6_sum(4), stage_4_sum(3), stage_4_carry(3));
Four_FA6  : FA port map(stage_6_sum(5), stage_6_carry(3), stage_6_sum(6), stage_4_sum(4), stage_4_carry(4));
Four_FA7  : FA port map(stage_6_sum(7), stage_6_carry(5), stage_6_sum(8), stage_4_sum(5), stage_4_carry(5));
Four_FA8  : FA port map(stage_6_sum(9), stage_6_carry(7), stage_6_sum(10), stage_4_sum(6), stage_4_carry(6));
Four_FA9  : FA port map(stage_6_sum(11), stage_6_carry(9), stage_6_sum(12), stage_4_sum(7), stage_4_carry(7));
Four_FA10 : FA port map(stage_6_sum(13), stage_6_carry(11), stage_6_sum(14), stage_4_sum(8), stage_4_carry(8));
Four_FA11 : FA port map(stage_6_sum(15), stage_6_carry(13), stage_6_sum(16), stage_4_sum(9), stage_4_carry(9));
Four_FA12 : FA port map(stage_6_sum(17), stage_6_carry(15), and_array(7,5), stage_4_sum(10), stage_4_carry(10));
Four_FA13 : FA port map(ACC(13), stage_6_carry(17), and_array(6,7), stage_4_sum(11), stage_4_carry(11));


-- Stage with Capacity = 3 bits

Three_HA1  : HA port map(ACC(1), and_array(0,1), stage_3_sum(0), stage_3_carry(0));
Three_FA2  : FA port map(stage_4_sum(0), and_array(1,1), and_array(2,0), stage_3_sum(1), stage_3_carry(1));
Three_FA3  : FA port map(stage_4_sum(1), stage_4_carry(0), and_array(3,0), stage_3_sum(2), stage_3_carry(2));
Three_FA4  : FA port map(stage_4_sum(2), stage_4_carry(1), and_array(4,0), stage_3_sum(3), stage_3_carry(3));
Three_FA5  : FA port map(stage_4_sum(3), stage_4_carry(2), stage_6_carry(2), stage_3_sum(4), stage_3_carry(4));
Three_FA6  : FA port map(stage_4_sum(4), stage_4_carry(3), stage_6_carry(4), stage_3_sum(5), stage_3_carry(5));
Three_FA7  : FA port map(stage_4_sum(5), stage_4_carry(4), stage_6_carry(6), stage_3_sum(6), stage_3_carry(6));
Three_FA8  : FA port map(stage_4_sum(6), stage_4_carry(5), stage_6_carry(8), stage_3_sum(7), stage_3_carry(7));
Three_FA9  : FA port map(stage_4_sum(7), stage_4_carry(6), stage_6_carry(10), stage_3_sum(8), stage_3_carry(8));
Three_FA10 : FA port map(stage_4_sum(8), stage_4_carry(7), stage_6_carry(12), stage_3_sum(9), stage_3_carry(9));
Three_FA11 : FA port map(stage_4_sum(9), stage_4_carry(8), stage_6_carry(14), stage_3_sum(10), stage_3_carry(10));
Three_FA12 : FA port map(stage_4_sum(10), stage_4_carry(9), stage_6_carry(16), stage_3_sum(11), stage_3_carry(11));
Three_FA13 : FA port map(stage_4_sum(11), stage_4_carry(10), and_array(7,6), stage_3_sum(12), stage_3_carry(12));
Three_FA14 : FA port map(ACC(14), stage_4_carry(11), and_array(7,7), stage_3_sum(13), stage_3_carry(13));


-- Final sums and carries are used by Brent Kung Adder

final_sums <= ACC(15) & stage_3_sum & ACC(0) ;
final_carries <= stage_3_carry & and_array(1,0) & and_array(0,0);

Adder_instance : Brent_Kung_Adder_16bit port map(final_sums, final_carries, '0', Sum, Cout);

end architecture MAC_8x8_Dadda_arch;